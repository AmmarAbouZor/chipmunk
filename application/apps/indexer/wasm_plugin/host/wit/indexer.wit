package host:indexer;

// *** PARSER ***
// Types definitions and methods provided be the host.
interface parsing {
  record parse-return {
    value: option<parse-yield>,
    cursor: u64,
  }

  record attachment {
    name: string,
    size: u64,
    created-date: option<string>,
    modified-date: option<string>,
    messages: list<u64>,
    data: list<u8>,
  }


  variant parse-yield {
    message(string),
    attachment(attachment),
    message-and-attachment(tuple<string, attachment>),
  }

  variant error {
    parse(string),
    incomplete,
    eof,
  }

  add: func(item: result<parse-return, error>);
  add-range: func(items: list<result<parse-return, error>>);
}

// Parse client using resources. 
// We define an interface as resource here and define its functions which must be implemented  
// by the client and can be called from the host.
interface parse-client {
  use parsing.{error, parse-return};

  resource parser {
    constructor();
    parse: func(data: list<u8>, timestamp: option<u64>) -> list<result<parse-return, error>>;
    parse-res: func(data: list<u8>, timestamp: option<u64>);
    parse-res-rng: func(data: list<u8>, timestamp: option<u64>);
  }
}

// World for the client which is using resource as an interface.
world parse {
  export parse-client;
}

// Parse client using an interface without resources.
// With this approach, the host doesn't need to instantiate the parser but the parser
// doesn't have a reference to itself on the method and must save it's state using statics 
// This approach is less performant than the ratio `1.04`
interface parse-client-inter {
  use parsing.{error, parse-return};

  init: func(configs: string) -> result<_, error>;
  parse: func(data: list<u8>, timestamp: option<u64>) -> list<result<parse-return, error>>;
  parse-res: func(data: list<u8>, timestamp: option<u64>);
}

// World for the client which is not using resource as an interface.
world parse-inter {
  export parse-client-inter;
}

// Parse Client that caches the bytes, returning one parse item at a time. 
// It calls the host for more bytes when it doesn't have more bytes to parse.
// This approach is far less performant as the ones who return all the items at once to 
// be cached by the source. They are about 6 times slower.
interface parse2-client {
  use parsing.{error, parse-return};

  resource parser {
    constructor();
    parse-next: func(timestamp: option<u64>) -> result<parse-return, error>;
  }
}

// World for the client which caches the bytes buffer in it, returning one result at a time.
world parse2{
    import source-host: interface {
      get-data: func() -> list<u8>;
    }    

    export parse2-client;
}


// *** BYTE-SOURCE ***
// Type definitions for parsing to be used by the host and the clients
interface sourcing {
  variant source-error {
    io(string),
    other(string),
  }
}

// Byte Source client definitions that must be implemented by the client and can be called from the host.
interface source-client {
  use sourcing.{source-error};

  resource byte-source{
    constructor();
    init: func(config-path: string, file-path: string) -> result<_, source-error>;
    read: func(len: u64) -> result<list<u8>, source-error>;
  }
}

world source {
  export source-client;
}

// Byte Source Client that does the buffering too, and instantiate a parser client from to call parse on it.
// This interface needs a parser client besides the host function and can be composed with a parser plugin to 
// produce a plugin that read that data, parse them, then sends the parse results to the host.
interface source-prod-client {
  use sourcing.{source-error};
  use parsing.{};
  use parse-client.{parser};

  resource source-prod{
    constructor();
    init: func(config-path: string, file-path: string) -> result<_, source-error>;
    read-then-parse: func(len: u64, bytes-read: u64, timestamp: option<u64>) -> result<_, source-error>;
  }
}

world producer {
  export source-prod-client;
}

