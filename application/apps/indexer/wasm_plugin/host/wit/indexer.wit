package host:indexer;

interface parsing {
  record parse-return {
    value: option<parse-yield>,
    cursor: u64,
  }

  record attachment {
    name: string,
    size: u64,
    created-date: option<string>,
    modified-date: option<string>,
    messages: list<u64>,
    data: list<u8>,
  }


  variant parse-yield {
    message(string),
    attachment(attachment),
    message-and-attachment(tuple<string, attachment>),
  }

  variant error {
    parse(string),
    incomplete,
    eof,
  }

  resource results {
      add: func(item: result<parse-return, error>);
      add-range: func(items: list<result<parse-return, error>>);
  }
}

interface parse-client {
  use parsing.{error, parse-return, results};

  resource parser {
    constructor();
    parse: func(data: list<u8>, timestamp: option<u64>) -> list<result<parse-return, error>>;
    parse-res: func(data: list<u8>, timestamp: option<u64>, results: borrow<results>);
    parse-res-rng: func(data: list<u8>, timestamp: option<u64>, results: borrow<results>);
  }
}

world parse {
  export parse-client;
}

interface parse2-client {
  use parsing.{error, parse-return};

  resource parser {
    constructor();
    parse-next: func(timestamp: option<u64>) -> result<parse-return, error>;
  }
}

world parse2{
    import source-host: interface {
      get-data: func() -> list<u8>;
    }    

    export parse2-client;
}

interface sourcing {
  variant source-error {
    io(string),
    other(string),
  }
}

interface source-client {
  use sourcing.{source-error};

  resource byte-source{
    constructor();
    init: func(config-path: string, file-path: string) -> result<_, source-error>;
    read: func(len: u64) -> result<list<u8>, source-error>;
  }
}

world source {
  export source-client;
}

interface source-prod-client {
  use sourcing.{source-error};
  use parsing.{results};
  use parse-client.{parser};

  resource source-prod{
    constructor();
    init: func(config-path: string, file-path: string) -> result<_, source-error>;
    read-then-parse: func(len: u64, bytes-read: u64, timestamp: option<u64>, results: borrow<results>) -> result<_, source-error>;
  }
}

world producer {
  export source-prod-client;
}

